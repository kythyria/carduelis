//! Simple transformation to HTML
//! 
//! This is a super hardcoded prototype.
//! Transformation is as follows:
//! 
//! Consecutive newlines become one less paragraph break than there is newlines, when phrasing content is present in a
//! flow-only context. If there's no paragraph break in places like `\li` then no paragraph element gets generated at 
//! all. Override with `nopara` or `paras` attributes.
//! 
//! You do not need to specify the `html` or `body` elements. A suitable `head` is autogenerated, tune it by making
//! `\doc` be the first element in the input. The head of `\doc` is the page title; both `<title>` and a `<h1>` are
//! generated, as well as metadata.
//! 
//! | Element           | Use                              |
//! |-------------------|----------------------------------|
//! | `\author{a}`      | Document author (text only).     |
//! | `\script(src)`    | External JS                      |
//! | `\script{code}`   | Inline JS                        |
//! | `\style(src)`     | External CSS                     |
//! | `\style{code}`    | Inline CSS                       |
//! | `\description{d}` | Document description (text only) |
//! | `\meta`, `\link`  | Same as HTML                     |
//! 
//! 
//! Elements not listed here are just passed through; specifying a head for them is an error.
//! 
//! These elements are special:
//! 
//! | CC                 | HTML    |
//! |--------------------|---------|
//! | `\+`               | `<ins>` |
//! | `\-`               | `<del>` |
//! | `\article(h){b}    | `<article>` starting with an appropriately-ranked header element containing `h`. |
//! | `\details(h){b}`   | `<details><summary>h</>b</>` |
//! | `\doc`             | Controls metadata and such. |
//! | `\figure(cap){con}`| `<figure>con<figcaption>cap</figcaption></figure>` (use `@top` to swap the order) |
//! | `\footnote(id){c}` | Footnote whose name is `id` and body is `c` |
//! | `\li(t){d}` (in `\dl`) | `<dt>t</dt><dd>d</dd>` as appropriate to if the head or body is given |
////! | `\pipetable`       | Render a very simple markdown-like table. |
//! | `\fnref(id)`       | Reference to the footnote with name `id`.   |
//! | `\section(h){b}`   | `<section>` starting with an appropriately-ranked header element containing `h`. |
//! | `\showtoc`         | `<nav>`, containing a copy of the page contents. |
//! | `\shownotes`       | Display footnotes here. What happens if this isn't after all footnotes is unspecified.
//! | `\table`           | `<table>`, but see below.
//! 
//! The following use the head for an attribute
//! 
//! | Element       | Head attribute | Notes |
//! |---------------|----------------|-------|
//! | `\a`          | `href`         |       |
//! | `\audio`      | `src`          | `controls` attribute is boolean, default `true`, despite the spec.          |
//! | `\abbr`       | `title`        |                                                                             |
//! | `\data`       | `value`        |                                                                             |
//! | `\dfn`        | `title`        |                                                                             |
//! | `\img`        | `src`          |                                                                             |
//! | `\label`      | `for`          |                                                                             |
//! | `\time`       | `datetime`     | If no body is given, a reasonable rendering will be automatically provided. |
//! | `\video`      | `src`          | As with `\audio`, `controls` is a default-true boolean.                     |
//! 
//! `\table`s mostly work like their HTML counterpart, but provide the `nlrow` attribute to make Newlines
//! start new rows, and `pipecol` to start a new cell using `\|`. `\footnote` is legal where a row would be;
//! such notes get appended immediately after the table itself.

use crate::caracara_6 as cc;

macro_rules! element_list {
    ($( $(#[$meta:meta])* $name:ident = $($item:ident)+ );+ ) => {
        $(
            $(#[$meta])*
            const $name: &[&str] = &[ $(stringify!($item)),+ ];
        )+
    };
}

element_list!(
    /// Elements that occur inside a paragraph when paragraph conversion is happening, and thus
    /// get wrapped in a paragraph.
    PHRASING_ELEMENTS =
    a abbr audio b bdi bdo br button canvas cite code data datalist del dfn em
    embed i iframe img input ins kbd label link map mark math meta meter
    noscript object output picture progress q ruby s samp script select slot 
    small span strong sub sup svg template textarea time u var video wbr
);

/// Convert n-1 parsed newlines to n paragraph breaks, and paragraph breaks into paragraphs.
fn paragraphise(mut input: Vec<cc::Node>) -> Vec<cc::Node> {
    #[derive(Clone, Copy, PartialEq, Eq)]
    enum Item {
        Phrasing,
        Flow,
        PotentialBreak
    }

    fn classify(el: &cc::Element) -> Item {
        if PHRASING_ELEMENTS.contains(&el.name.name.as_str()) {
            Item::Phrasing
        }
        else {
            Item::Flow
        }
    }

    let breaked = GroupWithKeysMut::new(input.as_mut_slice(), |item| match item {
        cc::Node::Newline(_) => Item::PotentialBreak,
        cc::Node::Element(e) => classify(e),
        cc::Node::Text(_) => Item::Phrasing,
    })
        .filter(|(key,items)| !(Item::PotentialBreak == *key && items.len() == 0))
        ;
    todo!();
}

struct GroupWithKeysMut<'a, I, P, K>
where
    P: Fn(&I) -> K,
    K: Clone + PartialEq
{
    remaining: &'a mut [I],
    grouper: P,
}
impl<'a, I, P, K> GroupWithKeysMut<'a, I,P,K>
where
    P: Fn(&I) -> K,
    K: Clone + PartialEq
{
    fn new(slice: &'a mut [I], grouper: P) -> Self {
        GroupWithKeysMut {
            remaining: slice,
            grouper
        }
    }
}

impl<'a, I, P, K> Iterator for GroupWithKeysMut<'a, I,P,K>
where
    P: Fn(&I) -> K,
    K: Clone + PartialEq
{
    type Item = (K, &'a mut [I]);
    fn next(&mut self) -> Option<<Self as Iterator>::Item> {
        let mut iter = self.remaining.iter();

        let mut key = iter.next().map(&self.grouper)?;
        let mut len = 1;
        while let Some(n) = iter.next() {
            let kn = (self.grouper)(n);
            if key == kn {
                len += 1;
                key = kn;
            }
            else {
                break;
            }
        }
        let slice = std::mem::take(&mut self.remaining);
        let (head, tail) = slice.split_at_mut(len);
        self.remaining = tail;
        Some((key, head))
    }
}